{
    "collab_server" : "",
    "contents" : "\n# This is the server logic for a Shiny web application.\n# You can find out more about building applications with Shiny here:\n#\n# http://shiny.rstudio.com\n\n\nshinyServer(function(input,output){\n  ## Maximum file input size: 30 MB\n  options(shiny.maxRequestSize=30*1024^2) \n  \n  ## Output household data\n  output$previewHousehold <- renderTable({\n    \n    req(input$household)\n    if (input$householddisp == \"head\") {\n      hh<-head(read.csv(input$household$datapath,\n                        header = input$householdheader,\n                        sep = input$householdsep,\n                        quote = input$householdquote))\n    } else {\n      hh<-read.csv(input$household$datapath,\n                   header = input$header,\n                   sep = input$sep,\n                   quote = input$quote)\n    }\n    return(hh)\n  })\n  \n  output$previewHouseholdTotal <- renderText({\n    req(input$household)\n    hh<-read.csv(input$household$datapath,\n                 header = input$householdheader,\n                 sep = input$householdsep,\n                 quote = input$householdquote)\n    hhnum<-length(unique(hh$HHID))\n    return(print(paste(hhnum, \"households have been found.\")))\n  })\n  \n  output$householdTotal <- DT::renderDataTable(DT::datatable({\n    req(input$household)\n    hh<-(read.csv(input$household$datapath,\n                  header = input$householdheader,\n                  sep = input$householdsep,\n                  quote = input$householdquote))\n    return(hh)\n  }))\n  \n  ## Output schedule data\n  output$previewSchedule <- renderTable({\n    req(input$schedule)\n    if (input$scheduledisp == \"head\") {\n      sched<-head(read.csv(input$schedule$datapath,\n                           header = input$scheduleheader,\n                           sep = input$schedulesep,\n                           quote = input$schedulequote))\n    } else {\n      sched<-read.csv(input$schedule$datapath,\n                      header = input$scheduleheader,\n                      sep = input$schedulesep,\n                      quote = input$schedulequote)\n    }\n    return(sched)\n  })\n  \n  output$previewScheduleTotal <- renderText({\n    \n    req(input$schedule)\n    sched<-read.csv(input$schedule$datapath,\n                    header = input$scheduleheader,\n                    sep = input$schedulesep,\n                    quote = input$schedulequote)\n    hhnum<-length(unique(sched$HHID))\n    schednum<-length(sched$EpisodeID)\n    print(paste(hhnum, \"households have been found with \",\n                schednum ,\"activitiy episodes.\"))\n  })\n  \n  output$scheduleTotal <- DT::renderDataTable(DT::datatable({\n    req(input$schedule)\n    sched <- read.csv(input$schedule$datapath,\n                      header = input$scheduleheader,\n                      sep = input$schedulesep,\n                      quote = input$schedulequote)\n    return(sched)\n  }))\n  \n  \n  # Misc\n  output$contents <- renderTable({\n    \n    req(input$schedule)\n    df <- read.csv(input$schedule$datapath,\n                   header = input$header,\n                   sep = input$sep,\n                   quote = input$quote)\n    \n    if(input$disp == \"head\") {\n      return(head(df))\n    }\n    else {\n      return(df)\n    }\n  })\n  \n  # read in shape file\n  ppcs <- rgdal::readOGR(\"~/ActivityPriority/Albatross4/data/ppcs_single.shp\",\n                         layer = \"ppcs_single\", GDAL1_integer64_policy = TRUE)\n  # set CRS\n  ppcs <- spTransform(ppcs, CRS(\"+init=EPSG:4326\"))\n \n  icons <- awesomeIcons(\n    icon = 'home',\n    iconColor = 'black',\n    library = 'fa'\n  )\n  \n  ############################################################################\n  ###########               Leaflet postcode map             #################\n  ############################################################################\n  # Leaflet postcode map\n  output$maphh <- renderLeaflet({\n    hh <- read.csv(input$household$datapath,\n                   header = input$header,\n                   sep = input$sep,\n                   quote = input$quote)\n    \n    \n    ppcsSample <- subset(ppcs, ppcs@data$PC4 %in% hh$Home)\n    \n    ppcsSample$Household[match(names(table(hh$Home)),ppcsSample$PC4)] <- table(hh$Home)\n    \n    labels <- sprintf(\n      \"<strong>PPC: %s</strong><br/>\n      # of Households: %g <br/>\n      Area: %g km<sup>2</sup>\",\n      ppcsSample$PC4,ppcsSample$Household, ppcsSample$Shape_Area / 10^6\n    ) %>% lapply(htmltools::HTML)\n    \n    min <- min(ppcsSample$Household,na.rm=T)\n    max <- max(ppcsSample$Household,na.rm=T)\n    bins <- c((max-min)*0.1 ,(max-min)*0.2,(max-min)*0.3,\n              (max-min)*0.4,(max-min)*0.5,(max-min)*0.6,(max-min)*0.7,\n              (max-min)*0.8,(max-min)*0.9, (max-min))\n    pal <- colorBin(\"YlOrRd\", domain = ppcsSample$Household, bins = bins)\n    \n    ########### Loop for getting household location coordinate #################\n    \n    coords <- c()\n    hhid <- c()\n    for (i in ppcsSample@data$PC4) {\n      n <- sum(ppcsSample$Household[ppcsSample$PC4 == i], na.rm = TRUE)\n      \n      hhid <- append(hhid,hh$HHID[hh$Home == i])\n      \n      polygon <- ppcsSample[ppcsSample@data$PC4 == i,]@polygons\n      \n      chosenPolygon <- 1\n      for (j in 1:length(polygon)) {\n        if (j > 1) {\n          if (polygon[[j]]@area > polygon[[j-1]]@area){\n            chosenPolygon <- j\n          }\n        }\n      }\n      \n      if (class(polygon) == \"list\" & length(polygon) > 1)  { ## For multi polygons PPC\n        polygon <- polygon[[chosenPolygon]]\n        if (length(polygon@Polygons) == 1) {\n          \n        } else {\n          chosen <- (polygon@plotOrder)[1]\n          polygon <- polygon@Polygons[[chosen]]\n        }\n      } else {\n        polygon <- polygon[[chosenPolygon]] \n        if (length(polygon@Polygons) == 1) {\n          \n        } else {\n          chosen <- (polygon@plotOrder)[1]\n          polygon <- polygon@Polygons[[chosen]]\n        }\n      }\n      \n      coords <- rbind(coords,spsample(polygon, n = n, type = \"random\")@coords)\n    }\n    hh$Lng <- coords[,1]\n    hh$Lat <- coords[,2]\n    \n    \n    ############################################################################\n    \n    # Write leaflet()\n    leaflet() %>%\n      setView(lng=5.00 , lat =52.00, zoom=8) %>%\n      \n      # Base groups\n      addTiles(group = \"OSM (default)\",\n               options = providerTileOptions(noWrap = TRUE)) %>%\n      # addProviderTiles(group = \"NatGeo (default)\", providers$Esri.NatGeoWorldMap) %>%\n      addProviderTiles(group = \"Toner Lite\", providers$Stamen.TonerLite) %>%\n      \n      # Overlay groups\n      addPolygons(data = ppcsSample,\n                  group = \"4-digit postcode area\",\n                  color = \"#444444\",\n                  weight = 1,\n                  smoothFactor = 0.5,\n                  opacity = 1.0,\n                  fill = TRUE,\n                  fillColor = \"#A9F5BC\",\n                  fillOpacity = 0.5,\n                  label = labels,\n                  labelOptions = labelOptions(\n                    style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"),\n                    textsize = \"15px\",\n                    direction = \"auto\"),\n                  highlightOptions = highlightOptions(color = \"white\",\n                                                      weight = 3,\n                                                      bringToFront = TRUE)) %>%\n      \n      addAwesomeMarkers(data = hh,\n                        lng = ~Lng,\n                        lat = ~Lat,\n                        layerId = ~HHID,\n                        # radius = 3,\n                        icon = icons,\n                        group = \"Household location\",\n                        label = ~(paste(\"HHID: \",as.character(HHID)))) %>%\n      \n      addPolygons(data = ppcsSample,\n                  group = \"Household choropleth\",\n                  color = \"#444444\",\n                  weight = 1,\n                  smoothFactor = 0.5,\n                  opacity = 1.0,\n                  fill = TRUE,\n                  fillColor = ~pal(Household),\n                  fillOpacity = 0.5,\n                  label = labels,\n                  labelOptions = labelOptions(\n                    style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"),\n                    textsize = \"15px\",\n                    direction = \"auto\"),\n                  highlightOptions = highlightOptions(color = \"white\",\n                                                      weight = 3,\n                                                      bringToFront = TRUE)) %>%\n      # Add legend for Household choropleth layer\n      addLegend(data = ppcsSample,\n                group = \"Household choropleth\",\n                pal = pal,\n                values = ~Household,\n                opacity = 0.7,\n                title = \"# of households\",\n                position = \"bottomright\") %>%\n      \n      # Layer Control\n      addLayersControl(\n        baseGroups = c(\"OSM (default)\", \"Toner Lite\"),\n        overlayGroups = c(\"4-digit postcode area\",\"Household choropleth\", \"Household location\"),\n        options = layersControlOptions(collapsed = FALSE)) %>%\n      \n      addMiniMap(toggleDisplay = TRUE, position = \"bottomleft\")\n  })\n  \n  acm_defaults <- function(maphh,x,y){\n    addCircleMarkers(maphh, x, y, radius = 3, color = \"black\", fillColor = \"orange\"\n                     # fillOpacity = 1, opacity = 1, weight = 2, stroke = TRUE,\n                     # layerID = \"Selected\"\n    )}\n  observeEvent(input$maphh_marker_click, {\n    click <- input$maphh_marker_click\n    if (is.null(click)){\n      return()\n    }\n    \n    proxy <- leafletProxy(\"maphh\")\n    proxy %>% setView(lng=click$lng, lat=click$lat, input$maphh_zoom) %>% acm_defaults(click$lng,click$lat)\n  })\n  \n  observe({\n    click <- input$maphh_marker_click\n    if (is.null(click)){\n      return()\n    }\n    text2<-paste(\"You've selected Household\", click$id)\n    output$Click_text<-renderText({\n      text2\n    })\n  })\n  \n  # data<-reactiveValues(clickedMarker=NULL)\n  observeEvent(input$maphh_marker_click,{\n    hh<-read.csv(input$household$datapath,\n                 header = input$header,\n                 sep = input$sep,\n                 quote = input$quote)\n    # data$clickedMarker <- input$map_marker_click\n    \n    output$clickedhh <- renderTable({\n      return(\n        # subset(hh,HHID == data$clickedMarker$id)\n        subset(hh,HHID == input$maphh_marker_click$id)\n      )\n    })\n  })\n  \n  output$mapsched <- renderLeaflet({\n    hh <- read.csv(input$household$datapath,\n                   header = input$header,\n                   sep = input$sep,\n                   quote = input$quote)\n    \n    \n    ppcs$Household[match(names(table(hh$Home)),ppcsSample$PC4)] <- table(hh$Home)\n    \n    labels <- sprintf(\n      \"<strong>PPC: %s</strong><br/>\n      Area: %g km<sup>2</sup>\",\n      ppcs$PC4,ppcs$Shape_Area / 10^6\n    ) %>% lapply(htmltools::HTML)\n    \n    min <- min(ppcsSample$Household,na.rm=T)\n    max <- max(ppcsSample$Household,na.rm=T)\n    bins <- c((max-min)*0.1 ,(max-min)*0.2,(max-min)*0.3,\n              (max-min)*0.4,(max-min)*0.5,(max-min)*0.6,(max-min)*0.7,\n              (max-min)*0.8,(max-min)*0.9, (max-min))\n    pal <- colorBin(\"YlOrRd\", domain = ppcs$Household, bins = bins)\n    \n    \n    \n    leaflet() %>%\n      setView(lng=5.00 , lat =52.00, zoom=8) %>%\n      \n      # Base groups\n      addTiles(group = \"OSM (default)\",\n               options = providerTileOptions(noWrap = TRUE)) %>%\n      addProviderTiles(group = \"NatGeo\", providers$Esri.NatGeoWorldMap) %>%\n      addProviderTiles(group = \"Toner Lite\", providers$Stamen.TonerLite) %>%\n      \n      # Overlay groups\n      addPolygons(data = ppcs,\n                  group = \"4-digit postcode area\",\n                  color = \"#444444\",\n                  weight = 1,\n                  smoothFactor = 0.5,\n                  opacity = 1.0,\n                  fill = TRUE,\n                  fillColor = \"#A9F5BC\",\n                  fillOpacity = 0.5,\n                  label = labels,\n                  labelOptions = labelOptions(\n                    style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"),\n                    textsize = \"15px\",\n                    direction = \"auto\"),\n                  highlightOptions = highlightOptions(color = \"white\",\n                                                      weight = 3,\n                                                      bringToFront = TRUE)) %>%\n      addPolygons(data = ppcs,\n                  group = \"Activity choropleth\",\n                  color = \"#444444\",\n                  weight = 1,\n                  smoothFactor = 0.5,\n                  opacity = 1.0,\n                  fill = TRUE,\n                  fillColor = ~pal(Household),\n                  fillOpacity = 0.5,\n                  label = labels,\n                  labelOptions = labelOptions(\n                    style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"),\n                    textsize = \"15px\",\n                    direction = \"auto\"),\n                  highlightOptions = highlightOptions(color = \"white\",\n                                                      weight = 3,\n                                                      bringToFront = TRUE))\n      \n      \n      # Layer control\n      addLayersControl(\n        baseGroups = c(\"OSM (default)\", \"NatGeo\", \"Toner Lite\"),\n        overlayGroups = c(\"4-digit postcode area\"),\n        options = layersControlOptions(collapsed = FALSE)) %>%\n      \n      addMiniMap(toggleDisplay = TRUE, position = \"bottomleft\")\n    \n  })\n})",
    "created" : 1525086660388.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2854224821",
    "id" : "6EB1C45C",
    "lastKnownWriteTime" : 1525276720,
    "last_content_update" : 1525276720395,
    "path" : "~/ActivityPriority/Albatross4/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}